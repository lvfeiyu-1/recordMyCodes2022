# recordMyCodes2022
upload my codes typed in 2022<br>

“单调栈”：<br>
在一维数组中对每一个数找到第一个比自己小的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。<br>

"并查集"：就是集合，能够快速合并，能够快速查询两个节点是否在同一集合中的一种数据结构。一般用树（数组）实现。<br>
并查集相关资料：<br>
1、并查集是一种数据结构<br>
2、并查集这三个字，一个字代表一个意思。<br>
3、并（Union），代表合并<br>
4、查（Find），代表查找<br>
5、集（Set），代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素<br>
6、并查集的典型应用是有关连通分量的问题<br>
7、并查集解决单个问题（添加，合并，查找）的时间复杂度都是O(1)<br>
8、因此，并查集可以应用到在线算法中<br>
<br>
简而言之滑动窗口就是：对一维数组使用“双指针”。<br>
《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。<br>
我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题：<br>
<pre>
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
</pre>
模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。<br>
另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间 [left, right] 不符合题意 。对于本题而言，就是该区间内的 0 的个数 超过了 2 。<br>
<br>
经过与官方的一些讨论，目前将计算过程仅与「两端点」相关的称为「双指针」，将计算过程与「两端点表示的区间」相关的称为「滑动窗口」。<br>
如果「滑动窗口」和「双指针」没有啥区别，可以互相替换，那么我们显然不会为一个笔试和面试中常考的知识点进行冗余的命名。<br>
<br>
「滑动窗口」是一个默认固定大小的窗口，在一些条件触发的情况下，可能会将其大小进行修改。<br>
「滑动窗口」本身并不是解决问题的一种方法（或者说算法），它其实就是这个问题本身。我们需要做的是寻找合适的数据结构来「维护」这个「滑动窗口」。<br>
<br>
很简单，就两句话。「滑动窗口」是一类问题本身，「双指针」是解决一类二分查找问题的通用优化方法。二者关联的问题之间没有任何关系。<br>
<br>

前缀和和差分互为逆运算<br>
<br>
回溯算法事实上就是在一个树形问题上做深度优先遍历，因此 首先需要把问题转换为树形问题。<br>
在画树形图的过程中，你一定会发现有些枝叶是没有必要的，把没有必要的枝叶剪去的操作就是剪枝，在代码中一般通过 break 或者 contine 和 return （表示递归终止）实现。<br>