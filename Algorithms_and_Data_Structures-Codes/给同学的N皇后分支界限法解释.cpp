#include<iostream>
#include<cmath>
using namespace std;

//（补充）每一行的棋子可以放的位置为 0~n-1  
//q[i]表示第i行上的皇后放在第 q[i] 列的位置上，假设q[2]=4,说明第 2 行的皇后放在第4列 
int q[12];
int n,j,l=0;//(i,j) (k,q[j]) 
//定义在全局的变量自动初始化为 0，包括 q[12] 每一位都是0 
//等价于  int n,j,l; //(i,j) (k,q[j]) 

void dfs_queen(int k)
{
	// 实际数组的有效行只有 0~n-1 行 
	//搜到第 n 行，说明位置搜索完毕了 
	//那么就输出 
	if(k==n&&l==0)
	{
		for(int i=0;i<n;i++)
		{
			//为什么加 1 ，简单易想 
			cout<<q[i]+1<<" ";
		}
		// l 加 1 后就不是 0 了 ，所以只会输出一次 
		l++;
		return;
	}
	
	// 外层循环遍历棋盘 "每一行的第 i 列" 
	for(int i=0;i<n;i++)                        //对整个棋盘进行遍历 
	{
		//内层循环遍历前 k 行 ，寻找每一行棋子能放第i个位置的棋子 
		for(j=0;j<k;j++)                       //检查是否可以放置 
		{	
			// k(或 j) 是行， i是列 ， 
			//条件 q[j]==i 是用来检测后面放的皇后不与前面的皇后在同一列 
			//abs(k-j)==abs(q[j]-i) 说明 两个棋子等于45度 或 135度（即在斜线上） 
			
			/**模拟过程说明原因*/ 
			
			//开始模拟，一开始 k == 0 ，i==0 
			// k == 0 ，j == 0 ,内层循环进不了，但是 j == k, 所以q[k]==i（第k行放第 i==0 列），此时皇后放在（0，0）点，然后检测下一行 即dfs_queen(k+1);
			// dfs_queen(k+1)结束后，i++， 继续检测第 k 行的下一列，由于 k 此时为 0，也进不了内循环 ，
			// 但是 j==k ,故 q[k]=i（第k行放第 i 列），此时皇后放在（0，1）点， 然后检测下一行 即dfs_queen(k+1);
			//依次类推，可知道第 0 行的皇后会尝试 4 个点，每个尝试都会往下判断一行
			
			//现在模拟 k == 1，即判断第 2 行时
			// j==0 , k==1,进入内循环，此时 i==0， q[j]==i 说明第 j 行第 i 列已经有皇后了 ，即(0,0)有皇后，所以不能把第二个皇后放在（k，i）,即（1，0），
			// （补充：说明条件 q[j]==i 是用来检测后面放的皇后不与前面的皇后在同一列）        
			// break，此时 j！=k，i++，检测下一列 
			// j==0，k==1,进入内循环，此时 i==1，q[j]!=i ，说明（0，1）没有皇后（第二个皇后可以放在（k，i），即（1，1）），
			// 但是 k-j==1，q[j]-i=0-1==-1 ,条件成立，break,
			//（补充部分1：k 代表 目前检测的这一行的下标 ，j代表 第 k 行的前面某一行的下标，q[j] 代表前面某一行皇后放的位置，i代表这一行皇后放的位置，即 i=q[k], 
			//  补充部分2：对于一元函数 y=x，x1-x2=y1-y2，而对于 y=-x，x1-x2=y2-y1,统一起来，前面两个一元函数有性质：abs(x1-x2)=abs(y1-y2)
			//  补充部分3：类比上面一元函数的性质，说明 条件abs(k-j)==abs(q[j]-i)是判断两个皇后是否成 45度 或 135度，即是否在同一条斜线上面） 
			//  此时 j!=k,i++,检测下一列
			//  j==0，k==1,进入内循环，此时 i==2，q[j]!=i ，说明（0，2）没有皇后（第二个皇后可以放在（k，i），即（1，2）），
			//又 k-j==1，q[j]-2=0-2==-2 ,于是 j++
			// 继续 
			//  j==1，k==1,不能进入内循环
			// 同时 j==k，满足条件判断，于是进行赋值 q[j]=i （即q[1]=2即第 2 行的皇后放在 第 3 列的位置上）
			
			if(q[j]==i||abs(k-j)==abs(q[j]-i))
			{
				break;
			}
		}
		
		
		if(j==k)
		{
			// 第k行棋子放在第 i 列的位置 
			q[k]=i;
			dfs_queen(k+1);
		}
	}
}

int main()
{
	//输入边长 n 
	std::cin>>n;
	//显然，1列也只能放一个 
	//这里传入的参数应该是代表 第 1 列（列下标从0开始） 
	dfs_queen(0);
	return 0;
} 
